<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Real-time</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.6.1/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
            background: white;
            margin: 20px;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .hidden {
            display: none !important;
        }

        /* Login Interface */
        .login-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .login-box {
            background: white;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.1);
            width: 400px;
            text-align: center;
        }

        .login-box h2 {
            margin-bottom: 30px;
            color: #333;
            font-size: 24px;
        }

        .form-group {
            margin-bottom: 20px;
            text-align: left;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .login-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .login-btn:hover {
            transform: translateY(-2px);
        }

        .login-btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
        }

        .message {
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        /* Chat Interface */
        .chat-container {
            display: flex;
            width: 100%;
            height: 100%;
        }

        .chat-sidebar {
            width: 350px;
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            display: flex;
            flex-direction: column;
        }

        .chat-header {
            padding: 20px;
            background: #667eea;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .user-info {
            display: flex;
            align-items: center;
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
            font-weight: bold;
        }

        .connection-status {
            display: flex;
            align-items: center;
            font-size: 12px;
            margin-top: 5px;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
            background: #dc3545;
        }

        .status-indicator.connected {
            background: #28a745;
        }

        .logout-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .logout-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .conversations-container {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .conversation-item {
            padding: 15px;
            margin-bottom: 5px;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.2s;
            border: 1px solid transparent;
        }

        .conversation-item:hover {
            background: #e9ecef;
        }

        .conversation-item.active {
            background: #667eea;
            color: white;
        }

        .conversation-name {
            font-weight: 500;
            margin-bottom: 5px;
        }

        .conversation-preview {
            font-size: 14px;
            color: #6c757d;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .conversation-item.active .conversation-preview {
            color: rgba(255, 255, 255, 0.8);
        }

        .unread-count {
            background: #dc3545;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            margin-left: auto;
        }

        .chat-main {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .chat-main-header {
            padding: 20px;
            background: white;
            border-bottom: 1px solid #e9ecef;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .chat-main-header h2 {
            color: #333;
            font-size: 18px;
        }

        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #f8f9fa;
        }

        .message {
            margin-bottom: 15px;
            display: flex;
            align-items: flex-start;
        }

        .message.own {
            justify-content: flex-end;
        }

        .message-bubble {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 20px;
            background: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        .message.own .message-bubble {
            background: #667eea;
            color: white;
        }

        .message-content {
            margin-bottom: 5px;
            word-wrap: break-word;
        }

        .message-meta {
            font-size: 12px;
            color: #6c757d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .message.own .message-meta {
            color: rgba(255, 255, 255, 0.8);
        }

        .message-status {
            font-size: 11px;
            margin-left: 5px;
        }

        .message-input-container {
            padding: 20px;
            background: white;
            border-top: 1px solid #e9ecef;
        }

        .message-input-form {
            display: flex;
            gap: 10px;
        }

        .message-input {
            flex: 1;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 25px;
            font-size: 16px;
            resize: none;
            max-height: 120px;
            transition: border-color 0.3s;
        }

        .message-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .send-btn {
            padding: 12px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
        }

        .send-btn:hover {
            background: #5a67d8;
        }

        .send-btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }

        .loading-conversations {
            text-align: center;
            color: #6c757d;
            padding: 20px;
        }

        .typing-indicator {
            display: flex;
            align-items: center;
            padding: 10px 16px;
            background: #e9ecef;
            border-radius: 20px;
            margin-bottom: 15px;
            font-style: italic;
            color: #6c757d;
        }

        .typing-dots {
            display: flex;
            gap: 3px;
            margin-left: 10px;
        }

        .typing-dot {
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: #6c757d;
            animation: typing 1.4s infinite;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
            }
            30% {
                transform: translateY(-10px);
            }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container {
                margin: 0;
                border-radius: 0;
                height: 100vh;
            }

            .chat-sidebar {
                width: 300px;
            }

            .login-box {
                width: 90%;
                margin: 20px;
            }
        }
    </style>
</head>
<body>
<!-- Login Interface -->
<div id="loginContainer" class="login-container">
    <div class="login-box">
        <h2>ƒêƒÉng nh·∫≠p Chat</h2>
        <form id="loginForm">
            <div class="form-group">
                <label for="loginEmail">Email:</label>
                <input type="email" id="loginEmail" name="email" required>
            </div>
            <div class="form-group">
                <label for="loginPassword">M·∫≠t kh·∫©u:</label>
                <input type="password" id="loginPassword" name="password" required>
            </div>
            <button type="submit" class="login-btn" id="loginBtn">ƒêƒÉng nh·∫≠p</button>
            <div id="loginMessage" class="message" style="display: none;"></div>
        </form>
    </div>
</div>

<!-- Chat Interface -->
<div id="chatContainer" class="container hidden">
    <div class="chat-sidebar">
        <div class="chat-header">
            <div class="user-info">
                <div class="user-avatar" id="userAvatar">U</div>
                <div>
                    <div id="userName">User</div>
                    <div class="connection-status">
                        <div class="status-indicator" id="connectionStatus"></div>
                        <span id="connectionText">ƒêang k·∫øt n·ªëi...</span>
                    </div>
                </div>
            </div>
            <button class="logout-btn" onclick="logout()">ƒêƒÉng xu·∫•t</button>
        </div>
        <div class="conversations-container">
            <div id="conversationsList">
                <div class="loading-conversations">
                    ƒêang t·∫£i cu·ªôc h·ªôi tho·∫°i...
                </div>
            </div>
        </div>
    </div>

    <div class="chat-main">
        <div class="chat-main-header">
            <h2 id="currentRoomName">Ch·ªçn m·ªôt cu·ªôc h·ªôi tho·∫°i ƒë·ªÉ b·∫Øt ƒë·∫ßu chat</h2>
        </div>
        <div class="messages-container" id="messagesContainer">
            <!-- Messages will be inserted here -->
        </div>
        <div class="message-input-container">
            <form class="message-input-form" id="messageForm">
                    <textarea
                            class="message-input"
                            id="messageInput"
                            placeholder="Nh·∫≠p tin nh·∫Øn c·ªßa b·∫°n..."
                            rows="1"
                    ></textarea>
                <button type="submit" class="send-btn" id="sendBtn">G·ª≠i</button>
            </form>
        </div>
    </div>
</div>

<script>
    // Configuration
    const API_BASE_URL = 'http://localhost:8080/api';
    const WS_URL = 'http://localhost:8080/ws';

    // Global variables
    let currentUser = null;
    let stompClient = null;
    let currentConversation = null;
    let conversations = [];
    let reconnectAttempts = 0;
    let maxReconnectAttempts = 5;
    let reconnectInterval = null;
    let typingTimeout = null;
    let typingUsers = new Set();

    // WebSocket subscriptions
    let subscriptions = [];

    // Initialize app
    document.addEventListener('DOMContentLoaded', function() {
        initializeApp();
    });

    function initializeApp() {
        // Check if user is already logged in
        const token = localStorage.getItem('jwt_token');
        const userData = localStorage.getItem('user_data');

        console.log('üöÄ Initializing app...');
        console.log('üîç JWT token exists:', !!token);
        console.log('üîç User data exists:', !!userData);

        if (token && userData) {
            try {
                currentUser = JSON.parse(userData);
                console.log('‚úÖ User loaded from localStorage:', currentUser.username || currentUser.email);

                // Show chat interface (which will also connect WebSocket)
                showChatInterface();
            } catch (error) {
                console.error('‚ùå Error parsing user data:', error);
                showLoginInterface();
            }
        } else {
            console.log('üîê No valid session found, showing login');
            showLoginInterface();
        }

        setupEventListeners();
    }

    function setupEventListeners() {
        // Login form
        document.getElementById('loginForm').addEventListener('submit', handleLogin);

        // Message form
        document.getElementById('messageForm').addEventListener('submit', handleSendMessage);

        // Auto-resize textarea
        const messageInput = document.getElementById('messageInput');
        messageInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 120) + 'px';

            // Handle typing indicator
            handleTypingIndicator();
        });

        // Handle Enter key
        messageInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleSendMessage(e);
            }
        });

        // Handle page visibility changes
        document.addEventListener('visibilitychange', handleVisibilityChange);

        // Handle beforeunload
        window.addEventListener('beforeunload', cleanup);
    }

    async function handleLogin(e) {
        e.preventDefault();
        const loginBtn = document.getElementById('loginBtn');
        const email = document.getElementById('loginEmail').value;
        const password = document.getElementById('loginPassword').value;

        loginBtn.disabled = true;
        loginBtn.textContent = 'ƒêang ƒëƒÉng nh·∫≠p...';

        try {
            const response = await fetch(`${API_BASE_URL}/auth/login`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ email, password })
            });

            const data = await response.json();

            if (response.ok && data.token) {
                // Save token and user data
                localStorage.setItem('jwt_token', data.token);

                // Ensure user data is properly saved
                const userData = {
                    id: data.id,
                    username: data.username,
                    email: data.email,
                    role: data.role,
                    avatarUrl: data.avatarUrl,
                    token: data.token,
                    type: data.type || 'Bearer',
                    success: true
                };

                localStorage.setItem('user_data', JSON.stringify(userData));
                currentUser = userData;

                console.log('‚úÖ Login successful, user data saved:', userData);

                showMessage('ƒêƒÉng nh·∫≠p th√†nh c√¥ng!', 'success');
                setTimeout(() => {
                    showChatInterface();
                    connectWebSocket();
                }, 1000);
            } else {
                showMessage(data.message || 'ƒêƒÉng nh·∫≠p th·∫•t b·∫°i!', 'error');
            }
        } catch (error) {
            console.error('Login error:', error);
            showMessage('L·ªói k·∫øt n·ªëi! Vui l√≤ng th·ª≠ l·∫°i.', 'error');
        } finally {
            loginBtn.disabled = false;
            loginBtn.textContent = 'ƒêƒÉng nh·∫≠p';
        }
    }

    function showLoginInterface() {
        document.getElementById('loginContainer').classList.remove('hidden');
        document.getElementById('chatContainer').classList.add('hidden');
    }

    function showChatInterface() {
        document.getElementById('loginContainer').classList.add('hidden');
        document.getElementById('chatContainer').classList.remove('hidden');

        // Ensure currentUser is set before doing anything
        if (!currentUser) {
            const userData = localStorage.getItem('user_data');
            if (userData) {
                try {
                    currentUser = JSON.parse(userData);
                    console.log('üîÑ Loaded currentUser from localStorage:', currentUser);
                } catch (error) {
                    console.error('‚ùå Error parsing user data:', error);
                    logout();
                    return;
                }
            } else {
                console.error('‚ùå No user data found, redirecting to login');
                logout();
                return;
            }
        }

        if (currentUser) {
            document.getElementById('userName').textContent = currentUser.username || currentUser.email;
            const avatar = document.getElementById('userAvatar');
            avatar.textContent = (currentUser.username || currentUser.email).charAt(0).toUpperCase();

            console.log('‚úÖ User interface setup complete for:', currentUser.username || currentUser.email);

            // Load conversations first
            loadConversations();

            // Connect WebSocket AFTER currentUser is confirmed
            console.log('üîå Starting WebSocket connection for user:', currentUser.id);
            connectWebSocket();
        } else {
            console.error('‚ùå Failed to set currentUser, redirecting to login');
            logout();
        }
    }

    function connectWebSocket() {
        const token = localStorage.getItem('jwt_token');
        if (!token) {
            updateConnectionStatus(false, 'Kh√¥ng c√≥ token');
            return;
        }

        if (!currentUser) {
            console.error('‚ùå No currentUser found when connecting WebSocket');
            return;
        }

        updateConnectionStatus(false, 'ƒêang k·∫øt n·ªëi...');
        console.log('üîå Connecting to WebSocket...');

        try {
            // Clear existing connection
            if (stompClient && stompClient.connected) {
                stompClient.disconnect();
            }

            const socket = new SockJS(WS_URL);
            stompClient = Stomp.over(socket);

            // Disable debug output for production
            stompClient.debug = null;

            const headers = {
                'Authorization': `Bearer ${token}`
            };

            stompClient.connect(headers,
                function(frame) {
                    console.log('‚úÖ WebSocket connected:', frame);
                    console.log('üîç Frame headers:', frame.headers);
                    console.log('üîç Current user at connection:', currentUser);

                    updateConnectionStatus(true, 'ƒê√£ k·∫øt n·ªëi');
                    reconnectAttempts = 0;

                    // Ensure currentUser is available before setting up subscriptions
                    if (currentUser && currentUser.id) {
                        console.log('üì° Setting up subscriptions for user:', currentUser.id);
                        setupSubscriptions();
                    } else {
                        console.error('‚ùå CurrentUser not available for subscriptions:', currentUser);
                        // Try to get user from localStorage again
                        const userData = localStorage.getItem('user_data');
                        if (userData) {
                            try {
                                currentUser = JSON.parse(userData);
                                console.log('üîÑ Recovered currentUser from localStorage:', currentUser);
                                setupSubscriptions();
                            } catch (e) {
                                console.error('‚ùå Failed to recover currentUser:', e);
                            }
                        }
                    }
                },
                function(error) {
                    console.error('‚ùå WebSocket connection failed:', error);
                    updateConnectionStatus(false, 'K·∫øt n·ªëi th·∫•t b·∫°i');
                    handleReconnect();
                }
            );

            // Handle socket events
            socket.onclose = function(event) {
                console.log('üîå WebSocket connection closed:', event);
                updateConnectionStatus(false, 'ƒê√£ ng·∫Øt k·∫øt n·ªëi');
                handleReconnect();
            };

            socket.onerror = function(error) {
                console.error('‚ùå WebSocket error:', error);
                updateConnectionStatus(false, 'L·ªói k·∫øt n·ªëi');
            };

        } catch (error) {
            console.error('‚ùå Failed to create WebSocket connection:', error);
            updateConnectionStatus(false, 'L·ªói k·∫øt n·ªëi');
            handleReconnect();
        }
    }

    function setupSubscriptions() {
        // Debug info
        console.log('üîç setupSubscriptions called');
        console.log('üîç stompClient:', stompClient);
        console.log('üîç stompClient.connected:', stompClient?.connected);
        console.log('üîç currentUser:', currentUser);

        // Clear existing subscriptions
        subscriptions.forEach(sub => {
            if (sub && sub.unsubscribe) {
                sub.unsubscribe();
            }
        });
        subscriptions = [];

        if (!stompClient || !stompClient.connected) {
            console.error('‚ùå Cannot setup subscriptions: STOMP client not connected');
            return;
        }

        if (!currentUser || !currentUser.id) {
            console.error('‚ùå Cannot setup subscriptions: currentUser not found or invalid');
            return;
        }

        console.log('üì° Setting up WebSocket subscriptions...');

        // Use custom queue destination based on userId
        const userQueueDestination = `/queue/user-${currentUser.id}`;
        console.log('üîë Using custom queue destination:', userQueueDestination);

        try {
            // Subscribe to private messages using custom queue
            const privateMessagesSub = stompClient.subscribe(userQueueDestination, function(message) {
                console.log('üì® Received private message:', message.body);
                handleReceivedMessage(message.body);
            });
            subscriptions.push(privateMessagesSub);
            console.log('‚úÖ Subscribed to:', userQueueDestination);

            // Subscribe to typing indicators
            const typingSub = stompClient.subscribe(`/queue/typing-${currentUser.id}`, function(message) {
                console.log('‚å®Ô∏è Received typing indicator:', message.body);
                handleTypingIndicator(message.body);
            });
            subscriptions.push(typingSub);

            // Subscribe to conversation updates
            const conversationsSub = stompClient.subscribe(`/queue/conversations-${currentUser.id}`, function(message) {
                console.log('üìã Received conversation update:', message.body);
                handleConversationUpdate(message.body);
            });
            subscriptions.push(conversationsSub);

            console.log('‚úÖ WebSocket subscriptions setup complete');
            console.log(`üì° Active subscriptions: ${subscriptions.length}`);

        } catch (error) {
            console.error('‚ùå Error setting up subscriptions:', error);
        }
    }

    function handleReceivedMessage(messageBody) {
        try {
            const message = JSON.parse(messageBody);
            console.log('‚úÖ SUCCESSFULLY RECEIVED MESSAGE via WebSocket:', message);

            // Debug current conversation state
            console.log('üîç Current conversation:', currentConversation);
            console.log('üîç Message senderId:', message.senderId);
            console.log('üîç Message receiverId:', message.receiverId);
            console.log('üîç Current user ID:', currentUser.id);


            let shouldDisplay = false;

            // Check if message is TO current user (incoming message)
            if (message.receiverId === currentUser.id) {
                shouldDisplay = true;
                console.log('üì± Message TO current user - will display');
            }
            // Check if message is FROM current user (outgoing message)
            else if (message.senderId === currentUser.id) {
                shouldDisplay = true;
                console.log('üì± Message FROM current user - will display');
            }
            // Check if it's for current conversation
            else if (currentConversation &&
                (message.senderId.toString() === currentConversation.otherUserId.toString() ||
                    message.receiverId.toString() === currentConversation.otherUserId.toString())) {
                shouldDisplay = true;
                console.log('üì± Message for current conversation - will display');
            }

            console.log('üîç Should display message:', shouldDisplay);

            if (shouldDisplay) {
                console.log('üì± Displaying message');

            } else {
                console.log('üì± Message not for display, updating conversation list only');
            }

            // Update conversation list
            updateConversationPreview(message);

            // Play notification sound if message is not from current user
            if (message.senderId !== currentUser.id) {
                playNotificationSound();
                console.log('üîî Played notification sound');
            }

        } catch (error) {
            console.error('‚ùå Error handling received message:', error);
            console.error('Raw message body:', messageBody);
        }
    }

    function handleTypingIndicator(typingData) {
        try {
            const data = JSON.parse(typingData);

            if (currentConversation && data.userId === currentConversation.otherUserId) {
                if (data.typing) {
                    showTypingIndicator(data.userName);
                } else {
                    hideTypingIndicator(data.userId);
                }
            }
        } catch (error) {
            console.error('‚ùå Error handling typing indicator:', error);
        }
    }

    function handleConversationUpdate(updateData) {
        try {
            const data = JSON.parse(updateData);

            // Reload conversations to reflect changes
            loadConversations();

        } catch (error) {
            console.error('‚ùå Error handling conversation update:', error);
        }
    }

    function handleReconnect() {
        if (reconnectAttempts >= maxReconnectAttempts) {
            console.log('‚ùå Max reconnect attempts reached');
            updateConnectionStatus(false, 'K·∫øt n·ªëi th·∫•t b·∫°i');
            return;
        }

        reconnectAttempts++;
        const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000); // Exponential backoff, max 30s

        console.log(`üîÑ Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts}) in ${delay}ms...`);
        updateConnectionStatus(false, `ƒêang k·∫øt n·ªëi l·∫°i... (${reconnectAttempts}/${maxReconnectAttempts})`);

        if (reconnectInterval) {
            clearTimeout(reconnectInterval);
        }

        reconnectInterval = setTimeout(() => {
            connectWebSocket();
        }, delay);
    }

    function updateConnectionStatus(connected, text) {
        const statusIndicator = document.getElementById('connectionStatus');
        const statusText = document.getElementById('connectionText');

        if (connected) {
            statusIndicator.classList.add('connected');
            statusText.textContent = text || 'ƒê√£ k·∫øt n·ªëi';
        } else {
            statusIndicator.classList.remove('connected');
            statusText.textContent = text || 'ƒê√£ ng·∫Øt k·∫øt n·ªëi';
        }
    }

    async function loadConversations() {
        const token = localStorage.getItem('jwt_token');

        try {
            const response = await fetch(`${API_BASE_URL}/chat/conversations`, {
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });

            if (response.ok) {
                conversations = await response.json();
                displayConversations(conversations);
            } else {
                console.error('Failed to load conversations:', response.status);
            }
        } catch (error) {
            console.error('Error loading conversations:', error);
        }
    }

    function displayConversations(conversations) {
        const conversationsList = document.getElementById('conversationsList');

        if (conversations.length === 0) {
            conversationsList.innerHTML = '<div class="loading-conversations">Ch∆∞a c√≥ cu·ªôc h·ªôi tho·∫°i n√†o</div>';
            return;
        }

        conversationsList.innerHTML = conversations.map(conversation => `
                <div class="conversation-item ${conversation.id === currentConversation ? 'active' : ''}"
                     onclick="selectConversation(${conversation.id}, '${conversation.otherUserId}', '${conversation.otherUserName}')">
                    <div class="conversation-name">${conversation.otherUserName}</div>
                    <div class="conversation-preview">${conversation.lastMessage || 'Ch∆∞a c√≥ tin nh·∫Øn'}</div>
                    ${conversation.unreadCount > 0 ? `<div class="unread-count">${conversation.unreadCount}</div>` : ''}
                </div>
            `).join('');
    }

    function selectConversation(conversationId, otherUserId, otherUserName) {
        currentConversation = {
            id: conversationId,
            otherUserId: otherUserId,
            otherUserName: otherUserName
        };

        // Update UI
        document.getElementById('currentRoomName').textContent = `Chat v·ªõi ${otherUserName}`;

        // Update conversation list
        document.querySelectorAll('.conversation-item').forEach(item => {
            item.classList.remove('active');
        });
        event.target.closest('.conversation-item').classList.add('active');

        // Load chat history
        loadChatHistory(otherUserId);
    }

    async function loadChatHistory(otherUserId) {
        const token = localStorage.getItem('jwt_token');

        try {
            const response = await fetch(`${API_BASE_URL}/chat/history/${otherUserId}`, {
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });

            if (response.ok) {
                const messages = await response.json();
                displayChatHistory(messages);
            } else {
                console.error('Failed to load chat history:', response.status);
            }
        } catch (error) {
            console.error('Error loading chat history:', error);
        }
    }

    function displayChatHistory(messages) {
        const messagesContainer = document.getElementById('messagesContainer');
        messagesContainer.innerHTML = '';

        messages.forEach(message => {
            displayMessage(message);
        });

        // Scroll to bottom
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    function handleSendMessage(e) {
        e.preventDefault();
        const messageInput = document.getElementById('messageInput');
        const content = messageInput.value.trim();

        if (!content || !currentConversation) return;

        if (!stompClient || !stompClient.connected) {
            showMessage('Ch∆∞a k·∫øt n·ªëi ƒë·∫øn server. Vui l√≤ng th·ª≠ l·∫°i!', 'error');
            return;
        }

        // Ensure receiverId is a number (backend expects Long)
        const receiverId = parseInt(currentConversation.otherUserId);
        if (isNaN(receiverId)) {
            console.error('‚ùå Invalid receiverId:', currentConversation.otherUserId);
            showMessage('L·ªói: ID ng∆∞·ªùi nh·∫≠n kh√¥ng h·ª£p l·ªá!', 'error');
            return;
        }

        const message = {
            senderId: parseInt(currentUser.id), // Ensure it's a number
            receiverId: receiverId,
            content: content,
            timestamp: new Date().toISOString()
        };

        console.log('üì§ Sending message via WebSocket:', message);
        console.log('üîç Backend will send to:');
        console.log(`  - Sender: /user/${currentUser.email}/queue/messages (if using email)`);
        console.log(`  - Sender: /user/${currentUser.id}/queue/messages (if using userId)`);

        // Find receiver email from conversations
        const conversation = conversations.find(c => c.id == currentConversation.id);
        if (conversation && conversation.otherUserEmail) {
            console.log(`  - Receiver: /user/${conversation.otherUserEmail}/queue/messages (email)`);
            console.log(`  - Receiver: /user/${conversation.otherUserId}/queue/messages (userId)`);
        } else {
            console.log(`  - Receiver: Will be determined by backend`);
        }

        try {
            // Send message via WebSocket
            stompClient.send('/app/chat.send', {}, JSON.stringify(message));

            // Display optimistic message
            const optimisticMessage = {
                ...message,
                senderName: currentUser.username || currentUser.email,
                status: 'sending'
            };
            displayMessage(optimisticMessage);

            // Clear input
            messageInput.value = '';
            messageInput.style.height = 'auto';

            // Stop typing indicator
            sendTypingIndicator(false);

        } catch (error) {
            console.error('‚ùå Error sending message:', error);
            showMessage('L·ªói g·ª≠i tin nh·∫Øn. Vui l√≤ng th·ª≠ l·∫°i!', 'error');
        }
    }

    function displayMessage(message) {
        const messagesContainer = document.getElementById('messagesContainer');
        const messageElement = document.createElement('div');

        const isOwnMessage = currentUser && (message.senderId === currentUser.id);
        messageElement.className = `message ${isOwnMessage ? 'own' : ''}`;

        const messageTime = message.timestamp || message.sentAt || new Date().toISOString();
        const timestamp = new Date(messageTime).toLocaleTimeString('vi-VN', {
            hour: '2-digit',
            minute: '2-digit'
        });

        const senderName = isOwnMessage ? 'B·∫°n' : (message.senderName || 'Unknown');
        const status = message.status ? `<span class="message-status">${getStatusText(message.status)}</span>` : '';

        messageElement.innerHTML = `
                <div class="message-bubble">
                    <div class="message-content">${escapeHtml(message.content)}</div>
                    <div class="message-meta">
                        <span>${senderName} ‚Ä¢ ${timestamp}</span>
                        ${status}
                    </div>
                </div>
            `;

        messagesContainer.appendChild(messageElement);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    function getStatusText(status) {
        switch (status) {
            case 'sending': return '‚è≥';
            case 'sent': return '‚úì';
            case 'delivered': return '‚úì‚úì';
            case 'read': return '‚úì‚úì';
            default: return '';
        }
    }

    function updateConversationPreview(message) {
        // Update the conversation list with new message preview
        const conversationItems = document.querySelectorAll('.conversation-item');
        conversationItems.forEach(item => {
            const conversationId = item.getAttribute('onclick').match(/selectConversation\((\d+)/)?.[1];
            if (conversationId) {
                const conv = conversations.find(c => c.id == conversationId);
                if (conv && (conv.otherUserId === message.senderId || conv.otherUserId === message.receiverId)) {
                    const preview = item.querySelector('.conversation-preview');
                    if (preview) {
                        preview.textContent = message.content.length > 50 ?
                            message.content.substring(0, 50) + '...' :
                            message.content;
                    }
                }
            }
        });
    }

    function sendTypingIndicator(isTyping) {
        if (!stompClient || !stompClient.connected || !currentConversation) return;

        const typingData = {
            userId: currentUser.id,
            userName: currentUser.username || currentUser.email,
            receiverId: currentConversation.otherUserId,
            typing: isTyping
        };

        try {
            stompClient.send('/app/chat.typing', {}, JSON.stringify(typingData));
        } catch (error) {
            console.error('‚ùå Error sending typing indicator:', error);
        }
    }

    function handleTypingIndicator() {
        // Send typing indicator
        sendTypingIndicator(true);

        // Clear existing timeout
        if (typingTimeout) {
            clearTimeout(typingTimeout);
        }

        // Set timeout to stop typing indicator
        typingTimeout = setTimeout(() => {
            sendTypingIndicator(false);
        }, 2000);
    }

    function showTypingIndicator(userName) {
        const messagesContainer = document.getElementById('messagesContainer');

        // Remove existing typing indicator
        const existingIndicator = messagesContainer.querySelector('.typing-indicator');
        if (existingIndicator) {
            existingIndicator.remove();
        }

        const typingElement = document.createElement('div');
        typingElement.className = 'typing-indicator';
        typingElement.innerHTML = `
                ${userName} ƒëang nh·∫≠p...
                <div class="typing-dots">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                </div>
            `;

        messagesContainer.appendChild(typingElement);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    function hideTypingIndicator(userId) {
        const messagesContainer = document.getElementById('messagesContainer');
        const typingIndicator = messagesContainer.querySelector('.typing-indicator');
        if (typingIndicator) {
            typingIndicator.remove();
        }
    }

    function playNotificationSound() {
        // Create a simple notification sound
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = 800;
            oscillator.type = 'sine';

            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.3);
        } catch (error) {
            console.log('Cannot play notification sound:', error);
        }
    }

    function handleVisibilityChange() {
        if (document.hidden) {
            console.log('üì± Page hidden - maintaining WebSocket connection');
        } else {
            console.log('üì± Page visible - checking WebSocket connection');
            if (!stompClient || !stompClient.connected) {
                console.log('üîÑ Reconnecting WebSocket...');
                connectWebSocket();
            }
        }
    }

    function cleanup() {
        console.log('üßπ Cleaning up...');

        // Stop typing indicator
        if (typingTimeout) {
            clearTimeout(typingTimeout);
        }
        sendTypingIndicator(false);

        // Clear reconnect interval
        if (reconnectInterval) {
            clearTimeout(reconnectInterval);
        }

        // Disconnect WebSocket
        if (stompClient && stompClient.connected) {
            stompClient.disconnect();
        }
    }

    function logout() {
        cleanup();

        localStorage.removeItem('jwt_token');
        localStorage.removeItem('user_data');
        currentUser = null;
        currentConversation = null;
        conversations = [];
        showLoginInterface();
    }

    function showMessage(message, type) {
        const messageDiv = document.getElementById('loginMessage');
        messageDiv.className = `message ${type === 'error' ? 'error-message' : 'success-message'}`;
        messageDiv.textContent = message;
        messageDiv.style.display = 'block';

        setTimeout(() => {
            messageDiv.style.display = 'none';
        }, 5000);
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Debug functions for testing
    window.testWebSocket = function() {
        if (stompClient && stompClient.connected) {
            console.log('‚úÖ WebSocket is connected');
            console.log('Current user:', currentUser);
            console.log('Current conversation:', currentConversation);
            console.log('Subscriptions count:', subscriptions.length);

            // Show all subscription paths
            console.log('üì° Subscription paths:');
            console.log(`  - /user/${currentUser.email}/queue/messages`);
            console.log(`  - /user/${currentUser.id}/queue/messages`);

            return true;
        } else {
            console.log('‚ùå WebSocket is not connected');
            return false;
        }
    };

    window.forceReconnect = function() {
        console.log('üîÑ Force reconnecting WebSocket...');
        reconnectAttempts = 0;
        connectWebSocket();
    };

    window.testMessage = function(content = 'Test message from console') {
        if (!currentConversation) {
            console.log('‚ùå No conversation selected');
            return;
        }

        const message = {
            senderId: currentUser.id,
            receiverId: currentConversation.otherUserId,
            content: content,
            timestamp: new Date().toISOString()
        };

        if (stompClient && stompClient.connected) {
            stompClient.send('/app/chat.send', {}, JSON.stringify(message));
            console.log('‚úÖ Test message sent:', message);
            console.log('üîç Expected to receive on:');
            console.log(`  - /user/${currentUser.email}/queue/messages (sender)`);

            // Find receiver info
            const conversation = conversations.find(c => c.id == currentConversation.id);
            if (conversation) {
                console.log(`  - /user/{receiver_email}/queue/messages (receiver)`);
            }
        } else {
            console.log('‚ùå WebSocket not connected');
        }
    };

    window.debugUser = function() {
        console.log('=== USER DEBUG INFO ===');
        console.log('Current user object:', currentUser);
        console.log('User ID:', currentUser?.id);
        console.log('User email:', currentUser?.email);
        console.log('User username:', currentUser?.username);
        console.log('JWT token exists:', !!localStorage.getItem('jwt_token'));
        console.log('Current conversation:', currentConversation);
    };

    window.testSelfMessage = function() {
        console.log('üß™ Testing self message...');
        const message = {
            senderId: currentUser.id,
            receiverId: currentUser.id,
            content: '[SELF TEST] Testing WebSocket to myself',
            timestamp: new Date().toISOString()
        };

        if (stompClient && stompClient.connected) {
            stompClient.send('/app/chat.send', {}, JSON.stringify(message));
            console.log('üì§ Self test message sent:', message);
            console.log('üîç Should receive on:', `/queue/user-${currentUser.id}`);
        } else {
            console.log('‚ùå WebSocket not connected');
        }
    };

    // Test backend debug - check if backend is processing messages
    window.testBackendReceive = function() {
        console.log('üß™ Testing backend message processing...');
        console.log('üì° Current subscriptions count:', subscriptions.length);

        // Create a test subscription to see raw WebSocket traffic
        if (stompClient && stompClient.connected) {
            console.log('üîç Creating debug subscriptions to catch ALL possible message paths...');

            const debugSubs = [];

            // Try all possible subscription paths
            const paths = [
                '/user/queue/messages',
                '/queue/messages',
                '/topic/messages',
                `/user/${currentUser.email}/queue/messages`,
                `/user/${currentUser.id}/queue/messages`,
                `/user/${currentUser.username || currentUser.email}/queue/messages`,
                '/topic/chat',
                '/queue/chat',
                '/user/queue/chat'
            ];

            paths.forEach((path, index) => {
                try {
                    const debugSub = stompClient.subscribe(path, function(message) {
                        console.log(`üéØ RECEIVED ON [${path}]:`, message.body);
                        console.log('üéØ Message headers:', message.headers);

                        // Try to parse and display
                        try {
                            const parsed = JSON.parse(message.body);
                            console.log('üéØ Parsed message:', parsed);
                            displayMessage(parsed);
                        } catch (e) {
                            console.log('üéØ Could not parse message:', e);
                        }
                    });
                    debugSubs.push(debugSub);
                    console.log(`‚úÖ Debug subscription ${index + 1} created: ${path}`);
                } catch (e) {
                    console.log(`‚ùå Failed to create subscription for ${path}:`, e);
                }
            });

            console.log(`‚úÖ ${debugSubs.length} debug subscriptions created`);

            // Send test message after a short delay
            setTimeout(() => {
                console.log('üöÄ Sending test message now...');
                testSelfMessage();
            }, 1000);

            // Store debug subscriptions for cleanup
            window.debugSubs = debugSubs;

            // Auto cleanup after 30 seconds
            setTimeout(() => {
                console.log('‚è∞ Auto-cleaning debug subscriptions after 30s...');
                cleanupDebugSubs();
            }, 30000);

        } else {
            console.log('‚ùå WebSocket not connected');
        }
    };

    // Debug WebSocket authentication and user resolution
    window.debugWebSocketAuth = function() {
        console.log('üîê DEBUGGING WEBSOCKET AUTHENTICATION');
        console.log('====================================');

        const token = localStorage.getItem('jwt_token');
        console.log('JWT Token exists:', !!token);
        console.log('JWT Token (first 50 chars):', token ? token.substring(0, 50) + '...' : 'null');

        console.log('Current user:', currentUser);
        console.log('WebSocket connected:', stompClient?.connected);
        console.log('WebSocket URL:', WS_URL);

        // Try subscribing to different user destination patterns
        if (stompClient && stompClient.connected) {
            console.log('üß™ Testing different user destination patterns...');

            const patterns = [
                `/user/queue/messages`,  // No user prefix - might work if Spring auto-resolves
                `/queue/messages`,       // Direct queue
                `/user/${currentUser.email}/queue/messages`,  // Email
                `/user/${currentUser.username}/queue/messages`,  // Username
                `/user/${currentUser.id}/queue/messages`,    // ID
            ];

            const testSubs = [];

            patterns.forEach((pattern, index) => {
                try {
                    const sub = stompClient.subscribe(pattern, function(message) {
                        console.log(`üéØ PATTERN ${index + 1} SUCCESS [${pattern}]:`, message.body);
                        alert(`SUCCESS on pattern: ${pattern}\nMessage: ${message.body}`);
                    });
                    testSubs.push(sub);
                    console.log(`‚úÖ Pattern ${index + 1} subscribed: ${pattern}`);
                } catch (e) {
                    console.log(`‚ùå Pattern ${index + 1} failed: ${pattern} - ${e.message}`);
                }
            });

            // Send test message after 2 seconds
            setTimeout(() => {
                console.log('üì§ Sending test message for pattern testing...');
                const testMsg = {
                    senderId: currentUser.id,
                    receiverId: currentUser.id,
                    content: '[PATTERN TEST] Testing all subscription patterns',
                    timestamp: new Date().toISOString()
                };
                stompClient.send('/app/chat.send', {}, JSON.stringify(testMsg));
            }, 2000);

            // Store for cleanup
            window.patternTestSubs = testSubs;

            // Auto cleanup
            setTimeout(() => {
                testSubs.forEach(sub => {
                    if (sub && sub.unsubscribe) {
                        sub.unsubscribe();
                    }
                });
                window.patternTestSubs = [];
                console.log('üßπ Pattern test subscriptions cleaned up');
            }, 30000);

        } else {
            console.log('‚ùå WebSocket not connected - cannot test patterns');
        }
    };

    // Force reconnect with detailed logging
    window.forceReconnectDetailed = function() {
        console.log('üîÑ FORCE RECONNECT WITH DETAILED LOGGING');
        console.log('======================================');

        // Cleanup existing connection
        if (stompClient && stompClient.connected) {
            console.log('üßπ Disconnecting existing WebSocket...');
            stompClient.disconnect();
        }

        const token = localStorage.getItem('jwt_token');
        if (!token) {
            console.log('‚ùå No JWT token found');
            return;
        }

        console.log('üîå Creating new WebSocket connection...');
        console.log('Token (first 20 chars):', token.substring(0, 20) + '...');

        try {
            const socket = new SockJS(WS_URL);
            stompClient = Stomp.over(socket);

            // Enable debug
            stompClient.debug = function(str) {
                console.log('STOMP DEBUG:', str);
            };

            const headers = {
                'Authorization': `Bearer ${token}`
            };

            console.log('üîê Connecting with headers:', headers);

            stompClient.connect(headers,
                function(frame) {
                    console.log('‚úÖ WebSocket connected successfully:', frame);
                    console.log('Frame details:', frame);
                    console.log('Frame headers:', frame.headers);

                    updateConnectionStatus(true, 'ƒê√£ k·∫øt n·ªëi');

                    // Setup subscriptions after successful connect
                    setTimeout(() => {
                        setupSubscriptions();
                        console.log('üì° Subscriptions setup complete');

                        // Test immediately
                        setTimeout(() => {
                            testSelfMessage();
                        }, 1000);
                    }, 500);
                },
                function(error) {
                    console.error('‚ùå WebSocket connection failed:', error);
                    updateConnectionStatus(false, 'K·∫øt n·ªëi th·∫•t b·∫°i');
                }
            );

        } catch (error) {
            console.error('‚ùå Failed to create WebSocket:', error);
        }
    };

    // Test with URL encoded username
    window.testEncodedUsername = function() {
        console.log('üß™ Testing with URL encoded username...');

        if (!stompClient || !stompClient.connected) {
            console.log('‚ùå WebSocket not connected');
            return;
        }

        const rawUsername = currentUser.username;
        const encodedUsername = encodeURIComponent(rawUsername);

        console.log('Raw username:', rawUsername);
        console.log('Encoded username:', encodedUsername);

        // Test multiple username formats
        const usernameFormats = [
            rawUsername,                    // "Tr·∫ßn B√°c Sƒ©"
            encodedUsername,               // "Tr%E1%BA%A7n%20B%C3%A1c%20S%C4%A9"
            rawUsername.replace(/\s+/g, '_'), // "Tr·∫ßn_B√°c_Sƒ©"
            rawUsername.replace(/\s+/g, '-'), // "Tr·∫ßn-B√°c-Sƒ©"
            'user-' + currentUser.id       // "user-2"
        ];

        const testSubs = [];

        usernameFormats.forEach((format, index) => {
            try {
                const path = `/user/${format}/queue/messages`;
                const sub = stompClient.subscribe(path, function(message) {
                    console.log(`üéØ SUCCESS with format ${index + 1} [${format}]:`, message.body);
                    alert(`SUCCESS with format: ${format}\nMessage: ${message.body}`);
                    handleReceivedMessage(message.body);
                });
                testSubs.push(sub);
                console.log(`‚úÖ Format ${index + 1} subscribed: /user/${format}/queue/messages`);
            } catch (e) {
                console.log(`‚ùå Format ${index + 1} failed: ${format} - ${e.message}`);
            }
        });

        // Send test message
        setTimeout(() => {
            console.log('üì§ Sending test message for username format testing...');
            const testMsg = {
                senderId: currentUser.id,
                receiverId: currentUser.id,
                content: '[USERNAME FORMAT TEST] Testing different username formats',
                timestamp: new Date().toISOString()
            };
            stompClient.send('/app/chat.send', {}, JSON.stringify(testMsg));
        }, 1000);

        // Store for cleanup
        window.usernameFormatSubs = testSubs;

        // Auto cleanup after 30 seconds
        setTimeout(() => {
            testSubs.forEach(sub => {
                if (sub && sub.unsubscribe) {
                    sub.unsubscribe();
                }
            });
            window.usernameFormatSubs = [];
            console.log('üßπ Username format test subscriptions cleaned up');
        }, 30000);
    };

    // Ultimate debug test - bypass everything and test direct WebSocket
    window.ultimateTest = function() {
        console.log('üöÄ ULTIMATE WEBSOCKET TEST');
        console.log('========================');

        if (!stompClient || !stompClient.connected) {
            console.log('‚ùå WebSocket not connected');
            return;
        }

        // Create the most comprehensive subscription test
        const allPossiblePaths = [
            '/user/queue/messages',
            '/queue/messages',
            '/topic/messages',
            '/topic/chat',
            '/user/2/queue/messages', // Hardcoded current user ID
            '/user/queue/2',
            `/user/${currentUser.id}/queue/messages`,
            `/user/${currentUser.email}/queue/messages`,
            `/queue/user-${currentUser.id}`,
            '/topic/broadcast',
            '/queue/reply'
        ];

        console.log('üîç Creating subscriptions for ALL possible paths...');
        const subs = [];

        allPossiblePaths.forEach((path, index) => {
            try {
                const sub = stompClient.subscribe(path, function(message) {
                    console.log(`üéØ JACKPOT! Received on [${path}]:`, message);
                    console.log('üéØ Message body:', message.body);
                    console.log('üéØ Message headers:', message.headers);

                    // Try to display the message
                    try {
                        const parsed = JSON.parse(message.body);
                        console.log('üéØ Parsed successfully:', parsed);
                        // Force display regardless of conversation
                        displayMessage(parsed);
                    } catch (e) {
                        console.log('üéØ Raw message (not JSON):', message.body);
                    }
                });
                subs.push(sub);
                console.log(`‚úÖ [${index + 1}] Subscribed to: ${path}`);
            } catch (e) {
                console.log(`‚ùå [${index + 1}] Failed: ${path} - ${e.message}`);
            }
        });

        console.log(`üì° Created ${subs.length} subscriptions`);

        // Send to multiple possible endpoints
        const testEndpoints = [
            '/app/chat.send',
            '/app/chat',
            '/app/message.send',
            '/app/send',
            '/app/test'
        ];

        const message = {
            senderId: currentUser.id,
            receiverId: currentUser.id,
            content: '[ULTIMATE TEST] Testing all endpoints and subscriptions',
            timestamp: new Date().toISOString(),
            type: 'CHAT'
        };

        console.log('üì§ Sending test message to multiple endpoints...');
        testEndpoints.forEach((endpoint, index) => {
            setTimeout(() => {
                try {
                    console.log(`üì§ [${index + 1}] Sending to: ${endpoint}`);
                    stompClient.send(endpoint, {}, JSON.stringify(message));
                } catch (e) {
                    console.error(`‚ùå [${index + 1}] Failed to send to ${endpoint}:`, e);
                }
            }, (index + 1) * 500); // 500ms delay between sends
        });

        // Store subscriptions for cleanup
        window.ultimateSubs = subs;

        // Auto cleanup after 1 minute
        setTimeout(() => {
            console.log('‚è∞ Auto-cleaning ultimate test subscriptions...');
            subs.forEach(sub => {
                if (sub && sub.unsubscribe) {
                    sub.unsubscribe();
                }
            });
            window.ultimateSubs = [];
        }, 60000);

        console.log('üéØ If ANY message is received, you will see "JACKPOT!" above');
        console.log('‚è∞ Test will auto-cleanup in 60 seconds');
    };

    // Auto-scroll to bottom when new messages arrive
    const messagesContainer = document.getElementById('messagesContainer');
    if (messagesContainer) {
        const observer = new MutationObserver(() => {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        });

        observer.observe(messagesContainer, {
            childList: true,
            subtree: true
        });
    }

    console.log('üöÄ Chat application initialized with WebSocket real-time support');
</script>
</body>
</html>